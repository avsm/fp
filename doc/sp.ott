metavar field, x, y, name, n            ::= {{ lex alphanum }} {{ com field label }}

metavar integer_literal, i              ::= {{ lex numeral }}  {{ com Literal integers }}

metavar alignment, current_alignment    ::= {{ lex alphanum }} {{ com Alignment expression }}

metavar value, v                        ::= {{ lex numeral }}  {{ com Constant values }}

indexvar index, j, k                    ::= {{ lex numeral }}  {{ com Indices }}

grammar

% Kinds of types.  Vectors and arrays are treated separately, since we
% don't have arrays of classifications (i.e. Sigma -> Map).
kind, K :: '' ::=                               {{ com Kinds }}
 | T                                ::  :: base_type    {{ com Base types }}
 | Sigma -> T                       ::  :: vectors      {{ com Vector types }}  {{ tex \sigma\rightarrow [[T]] }}
 | Struct                           ::  :: struct_type  {{ com Struct types }}
 | Sigma -> Struct                  ::  :: array        {{ com Array types }}   {{ tex \sigma\rightarrow [[Struct]] }}
 | Map                              ::  :: map          {{ com Cases types }}

% Primitive types.  Note that int is only here as an interface to the
% int type of the implementation language used by the generated code
% (e.g. Ocaml); it's only used in the value expression typing rules.
base, b :: '' ::=                               {{ com Base types }}
 | bit                      ::  :: bit
 | byte                     ::  :: byte
 | int16                    ::  :: int16
 | int32                    ::  :: int32
 | int64                    ::  :: int64
 | int                      ::  :: int

% These are expressions that are used to specify vector-lengths, and a
% slight extension of these expressions will be used to specify value
% specifications.
exp, e :: '' ::=                                {{ com Expressions }}
 | integer_literal          ::  :: integer
 | x                        ::  :: field_ref
 | e1 + e2                  ::  :: addition
 | e1 - e2                  ::  :: subtraction
 | e1 * e2                  ::  :: multiplication
 | e1 / e2                  ::  :: division
 | ( e )                    ::  :: grouping
 | sizeof x                 ::  :: sizeof
 | offset x                 ::  :: offset
 | num_set_bits x           ::  :: num_set_bits
 | remaining ()             ::  :: remaining

% The path expressions are used in branch case guards and value
% expressions.
path, p :: '' ::=                               {{ com Path expressions }}
 | x                        ::  :: path_leaf
 | path . x                 ::  :: dot_path

% Note that this definition allows fields inside structs to have
% struct types.  Also, the value expressions for fields are seperated
% out into a separate syntactic rule, and appear in a struct after
% field declarations.  This has been done to ease the typing
% specification, since the environment for the value expressions
% includes _all_ the fields in the enclosing struct, including fields
% that lexically come later in the actual language.
tau {{ tex \tau }} :: '' ::=                    {{ com Type expressions }}
 | b                            ::  :: base
 | b [ e ]                      ::  :: vector
 | struct { D ;; VD }           ::  :: struct
 | </ vj , nj , tauj // j />    ::  :: cases_struct
 | ( e , tau )                  ::  :: array_struct

% A sequence of field and alignment declarations.
D :: '' ::=                                     {{ com Declarations }}
 |                          ::  :: nil_decl
 | F ; D                    ::  :: cons_decl

% A field or alignment declaration.
F :: '' ::=                                     {{ com Labeled Fields }}
 | align e                              ::  :: alignment
 | x : label                            ::  :: label
 | x : tau                              ::  :: field
 | x : array ( e ) { D ;; VD }          ::  :: struct_array
 | x : classify ( y ) { cases }         ::  :: classify

cases :: '' ::=                                 {{ com Classification trees }}
 | </ ej : nj -> { Dj ;; VDj } // j />  ::  :: cases

% The value declarations are unordered, so we should use a list form.
% This ensures that we use the same environment for each decl, and
% also enables us to define one less typing production.  However, Ott
% had issues with the way I attempted it ...
VD :: '' ::=                                    {{ com Value declarations }}
 | </ Vj // j />            ::  :: value_decls

V :: '' ::=                                     {{ com Field value specification }}
 | x : value_cases          ::  :: value_case_decls

value_cases, vcs :: '' ::=                      {{ com Value cases }}
 | </ value_casej // j />   ::  :: value_cases

value_case, vc :: '' ::=                        {{ com Value case }}
 | bcases -> value_exp      ::  :: value_case

bcases, cs :: '' ::=                            {{ com Branch case }}
 |                          ::  :: nil_branch_case
 | bcases ; branch_case     ::  :: cons_branch_case

branch_case, bc :: '' ::=                       {{ com Branch guard }}
 | path = n                 ::  :: branch_guard

% The path syntax allows value expressions to refer to fields within
% classification trees.
value_exp, ve :: '' ::=                         {{ com Value expressions }}
 | e                        ::  :: expr
 | path                     ::  :: qualified_field
 | sizeof path              ::  :: path_sizeof
 | offset path              ::  :: path_offset
 | num_set_bits path        ::  :: path_num_set_bits

E :: '' ::=                                     {{ com Typing environments }}
 |                          ::  :: env_nil
 | x : tau                  ::  :: env_cons
 | x : label                ::  :: env_label
 | E1 ; E2                  ::  :: env_append
 | E1 \ E2                  ::  :: env_subtract

% The classification tree environment stores the current set of paths
% in the classification tree.  The paths point to the selected Struct
% within a Map.
C :: '' ::=
 |                          ::  :: class_env_nil
 | path : Struct            ::  :: class_env_cons
 | C1 ; C2                  ::  :: class_env_append

% Sets containing field and label names.
S, L :: '' ::=                                  {{ com Label and name sets }}
 | Empty                     ::  :: nil         {{ com Empty set }}             {{ tex \empty }}
 | S + x                     ::  :: set_union   {{ com Set union }}             {{ tex [[S]] \cup {[[x]]} }}

% The ( exp ) production is purely a mechanism to inject expressions
% as alignments, without disambiguation.  const_fold is a function
% that is defined when exp can be constant-folded into a constant, and
% is not defined otherwise.
align_expr, a :: '' ::=                         {{ com Alignment expressions }}
 | current_alignment        ::  :: align_var
 | integer_literal          ::  :: align_const
 | ( exp )                  ::  :: align_exp
 | a1 + a2                  ::  :: align_plus
 | a1 * a2                  ::  :: align_multiple
 | const_fold ( exp )       ::  :: align_const_fold
 | sizeof ( tau )           ::  :: align_sizeof

formula :: formula_ ::=
 | judgement                    ::  :: judgement
 | </ formulaj // j />          ::  :: formula_list
 | E ; x : tau ; E'             ::  :: env
 | x in S                       ::  :: in_S             {{ tex [[x]]\not\in [[S]] }}
 | x not in S                   ::  :: not_in_S         {{ tex [[x]]\not\in [[S]] }}
 | x : tau in fields ( tau' )   ::  :: in_fields_tau    {{ tex [[x]] [[:]] [[tau]] \in fields([[tau']]) }}
 | n in </ nj // j />           ::  :: in_keys          {{ tex [[n]] \in { [[n]]_j } }}
 | E ( x ) = label              ::  :: label_in_E
 | a                            ::  :: current_alignment
 | a '%' i1 = i2                ::  :: alignment_boundary
 | a < a'                       ::  :: alignment_compare
 | v = a                        ::  :: alignment_equal
 | T_to_int ( tau )             ::  :: type_cast_to_int
 | T_from_int ( tau )           ::  :: type_cast_from_int
 | distinct ( </ nj // j /> )   ::  :: distinct_names
 | n in branches ( Map )        ::  :: names_in_map
 | C1 ; path : Struct ; C2      ::  :: class_env
 | path  in dom ( C )           ::  :: path_in_class_env
 | path not in dom ( C )        ::  :: path_not_in_class_env
 | Map [ n ] = Struct           ::  :: branch_selection
 | x in dom ( Struct )          ::  :: field_in_struct
 | Struct [ x ] = tau           ::  :: struct_selection

terminals :: '' ::=                             {{ com Syntax terminals }}
 | ->                       ::  :: rarrow       {{ tex \rightarrow }}
 | |-                       ::  :: vdash        {{ tex \vdash }}

defns
Type_checked_parsing :: '' ::=

% Environment lookup for variables.
defn
E ( x ) = tau     ::  :: typing_context :: 'typing_context_' by

E1 ; x : tau ; E2
--------------------------  :: var
E ( x ) = tau

% Class environment lookup for paths.
defn
C |- path : Struct  ::  :: class_env_contect :: 'class_env_context_' by

C1 ; path : Struct ; C2
--------------------------  :: path
C |- path : Struct

% Rules to type length expressions.
%
% Expression typing is used for vector and array length expressions,
% and value specifiers.  In the former case, we are interested if the
% expression can be typed as an integer.  In the latter case, we are
% interested if the value expression can be typed with the type
% carried by the field.
%
% Although array expressions and value expressions have been
% differentiated syntactically above (to handle paths in value
% expressions), they will be typed using the same typing relation, and
% the difference between the two is implemented in the typing relation
% for V (field_value_typing).
defn
E |- exp : int ::  :: array_size_typing :: 'array_size_typing_' by

--------------------------  :: int
E |- integer_literal : int

% We handle bit-vectors specially, and the generic case below: they
% can be converted into integers if their length is a constant and
% less then a limit.
E ( x ) = bit [ e ]
const_fold ( e ) < 32
--------------------------  :: var_bit_vector
E |- x : int

% This is the more generic case.
E ( x ) = tau
T_to_int ( tau )
--------------------------  :: var
E |- x : int

E |- e1 : int
E |- e2 : int
--------------------------  :: addition
E |- e1 + e2 : int

E |- e1 : int
E |- e2 : int
--------------------------  :: subtraction
E |- e1 - e2 : int

E |- e1 : int
E |- e2 : int
--------------------------  :: multiplication
E |- e1 * e2 : int

E |- e1 : int
E |- e2 : int
--------------------------  :: division
E |- e1 / e2 : int

E |- e : int
--------------------------  :: grouping
E |- (e) : int

E ( x ) = tau
--------------------------  :: sizeof
E |- sizeof x  : int

E ( x ) = tau
--------------------------  :: offset
E |- offset x  : int

E ( x ) = label
--------------------------  :: offset_label
E |- offset x  : int

E ( x ) = tau
--------------------------  :: num_set_bits
E |- num_set_bits x  : int

--------------------------  :: remaining
E |- remaining ()  : int

% Rules to ensure that type expressions are well-kinded.  We also
% thread an alignment offset 'a' through the rules, since type
% expressions are only well-kinded only at certain alignments.
% Specifically, non-bit-oriented types are only well-kinded at byte
% offsets.  Hence, all byte-aligned offsets are equivalent to offset
% 0.
defn
E , a |- tau : K , a'       ::  :: kinding :: 'kinding_' by

--------------------------  :: bit
E , a |- bit : T , a + 1

E |- e : int
--------------------------  :: bit_vector
E, a |- bit[e] : Sigma -> T , a + (e)

% All non-bit types are required to be byte-aligned.

a % 8 = 0
--------------------------  :: byte
E , a |- byte : T , 0

a % 8 = 0
--------------------------  :: int16
E , a |- int16 : T , 0

a % 8 = 0
--------------------------  :: int32
E , a |- int32 : T , 0

a % 8 = 0
--------------------------  :: int64
E , a |- int64 : T , 0

a % 8 = 0
E |- e : int
--------------------------  :: byte_vector
E, a |- byte[e] : Sigma -> T , 0

a % 8 = 0
E |- e : int
--------------------------  :: int16_vector
E, a |- int16[e] : Sigma -> T , 0

a % 8 = 0
E |- e : int
--------------------------  :: int32_vector
E, a |- int32[e] : Sigma -> T , 0

a % 8 = 0
E |- e : int
--------------------------  :: int64_vector
E, a |- int64[e] : Sigma -> T , 0

% TODO: We need to add some check for D!
a % 8 = 0
--------------------------  :: struct
E, a |- struct { D ;; VD } : Struct, 0

% TODO: We need to add some check for tau!
a % 8 = 0
E |- e : int
--------------------------  :: array
E, a |- ( e, tau ) : Sigma -> Struct, 0

% For cases, we need to check that each case branch will leave the
% subsequent fields suitably aligned.
a % 8 = 0
</ E, a |- tauj : Kj , aj // j />
</ aj % 8 = 0 // j />
--------------------------  :: cases
E, a |- </ vj , nj , tauj // j /> : Map, 0

% TODO:
%
% This rule type checks a top-level struct.  Note that the environment
% threading in this rule adds the fields in the struct to the
% environment without any qualification.  This will be rectified for
% nested structs, below.  Also, note that the environment used to type
% VD is the one computed after typing D.
% E , a |- D , E' , a'
% E' |- VD
% --------------------------  :: named_struct
% E , a |- struct n { D ;; VD } : Struct, a'

% There is no rule for typing an unamed array struct, since this will
% never appear in the source syntax.


% Rules to process a sequence of field and alignment declarations.
% Since field and label names cannot conflict, and since there cannot
% be duplicate field or label names, we thread a set of current names
% through the rules.
defn
E , a , S |- D , E' , a' , S'   ::  :: decls_typing :: 'decls_typing_' by

% That's not a typo: it's the null decl!
--------------------------  :: nil
E , a , S |- , E , a , S

E  , a ,  S  |- F , E'  , a'  , S'
E' , a' , S' |- D , E'' , a'' , S''
--------------------------  :: decl_cons
E , a , S    |- F ; D , E'' , a'' , S''

% Rules to process a single field or alignment declaration.  Alignment
% declarations update the bit alignment, and field declarations add to
% the environment as well as update the bit alignment, and so each
% rule will output a possibly modified environment and an updated bit
% alignment.  We also thread a set of field and label names to check
% for conflicts.
defn
E , a , S |- F , E' , a' , S'   ::  :: field_typing :: 'field_typing_' by

% We only support constant expressions for alignment values, and only
% support alignment at byte boundaries.
const_fold ( e ) % 8 = 0
--------------------------  :: alignment
E , a , S |- align e , E , 0 , S

% A label is simply added to the environment as a label; in
% particular, the current alignment is unchanged.  We support labels
% only at byte boundaries.

a % 8 = 0
x not in S
--------------------------  :: label
E , a , S |- x : label , E ; x : label , 0 , S + x

% We don't have a single rule for x : tau, but instead seperate out
% the rules for the top level cases of tau.  This is to specially
% handle the case where tau is a struct.

x not in S
E , a |- b : K , a'
--------------------------  :: base
E , a , S |- x : b , E ; x : b , a' , S + x

x not in S
E , a |- b [ e ] : K , a'
--------------------------  :: vector
E , a , S |- x : b [ e ] , E ; x : b [ e ] , a' , S + x

% The array needs to start and end on a byte-boundary.  Note the
% adjustment of the environment for typing value expressions.  This is
% to enforce layering, i.e. generation code of embedded struct fields
% cannot depend on the embedding environment.  This ensures that
% structs can be generated bottom up.

x not in S
a % 8 = 0
E |- e : int
E , 0 , Empty |- D , E' , a' , S'
( e ) * a' % 8 = 0
E' \ E |- VD
--------------------------  :: array
E , a , S |- x : array ( e ) { D ;; VD } , E ; x : ( e , struct { D ;; VD } ) , 0 , S + x

% The field y should not be a label.  The root of the classification
% tree should be byte-aligned, and each path in the classification
% tree should end on a byte-aligned boundary.  Layering is again
% enforced by adjusting the environment the value expressions of each
% classified struct are typed in.

x not in S
a % 8 = 0
E ( y ) = tau
distinct ( </ nj // j /> )
vj = const_fold ( ej )
</ E , 0 , Empty |- Dj , Ej , aj , Sj // j />
aj % 8 = 0
</ Ej \ E |- VDj // j />
--------------------------  :: classify
E , a , S |- x : classify ( y ) { </ ej : nj -> { Dj ;; VDj } // j /> } , E ; x : </ vj , nj , struct { Dj ;; VDj } // j /> , 0 , S + x

% Value expressions.

defn
E |- VD                     ::  :: field_values_typing :: '' by

</ E |- Vj // j />
--------------------------  :: field_values
E |- </ Vj // j />

defn
E |- V                      ::  :: value_case_decl_typing :: '' by

% Implementation note: An exception to the base-type restriction is
% when the field is a bit-vector; in which case, the value expression
% should evaluate to an appropriate integer valued constant.
E ( x ) = base
</ E |- value_casej : base // j />
--------------------------  :: value_cases
E |- x : value_cases

% This relation specifies how the environment used for path lookups is
% built from the branch case specifications for the value expression.
% Note that the environment E in this relation is a restricted
% environment, containing only the field <-> type assignments for the
% immediately enclosing struct; outer enclosing structs are not
% present.  This is from the layering constraint mentioned enforced
% above.
defn
E , C |- branch_case : C'   ::  ::  branch_case_env :: '' by

% Single component paths, must refer to fields in the immediately
% enclosing struct.  We disallow repeated branch cases, hence this
% path must not be present in dom(C), but looked up in the environment
% E.
E ( x ) = tau
E , 0 |- tau : Map , a'
x not in dom ( C )
n in branches ( Map )
Map [ n ] = Struct
--------------------------  :: leaf_guard_check
E , C |- x = n : C ; x : Struct

% Multicomponent paths are looked up in C based on their prefix.
path in dom ( C )
C |- path : Struct
Struct [ x ] = tau
E , 0 |- tau : Map , a'
Map [ n ] = Struct
--------------------------  :: path_guard_check
E , C |- path . x  = n : C ; x : Struct

% This relation merely specifies how to process a list of branch
% cases.
defn
E , C |- bcases : C'        ::  :: class_env_spec :: '' by

--------------------------  :: nil_class_env_spec
E , C |- : C

E , C  |- bcases : C'
E , C' |- branch_case : C''
--------------------------  :: cons_class_env_spec
E , C |- bcases ; branch_case : C''

% A value_case is processed by first computing the classification tree
% environment from the specified branch cases, and then typing the
% value_exp.
defn
E |- value_case : tau       ::  :: value_case_typing :: '' by

E , |- bcases : C
E , C |- value_exp : tau
--------------------------  :: value_case
E |- bcases -> value_exp : tau

% This relation computes the type of a value_exp given the two
% environment components.  This is largely similar to the typing of
% expressions in the parsing facet, with the following differences:
% - paths appear only in value expressions, and need to be looked up
%   using the classification tree environment C
% - some functions (e.g. sizeof, offset) appear only in value
%   expressions.
defn
E , C |- value_exp : tau    ::  :: value_exp_typing :: '' by

E ( x ) = tau
--------------------------  :: field_value
E , C |- x : tau

C |- path : Struct
Struct [ x ] = tau
--------------------------  :: path_value
E , C |- path . x : tau

E , C |- path : tau
--------------------------  :: sizeof
E , C |- sizeof path : int

E , C |- path : tau
--------------------------  :: offset
E , C |- offset path : int

E , C |- path : bit [ e ]
--------------------------  :: num_set_bits
E , C |- num_set_bits path : int

% For other forms of value expressions, we merely repeat the
% expression typing rules, with the addition of C as a component of
% the environment.  We avoid repeating these rules here.
